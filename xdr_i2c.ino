#include <avr/pgmspace.h>
#include <I2cMaster.h>
#include <IRremote.h>
#define RDS_PIN 2
// IR_PIN 3
#define RESET_PIN 4
#define SDA_PIN A4
#define SCL_PIN A5

uint8_t mode; // 1=FM, 2=AM
uint8_t CONTROL = 0x00, PLLM, PLLL, DAA, AGC = 0xC8, BAND; // TEF6730 tuning data
uint8_t rds_buffer[4], pi_buffer[2] = {0x00}, pi_ok_buffer[2] = {0x00};
unsigned long timer = 0, rds_timer = 0;

const uint8_t FM0[] PROGMEM = {0xFF, 0xFD, 0xFF, 0xF9, 0xFF, 0xF4, 0xFF, 0xF4, 0xFF, 0xFA, 0x00, 0x0A, 0x00, 0x20, 0x00, 0x34, 0x00, 0x3A, 0x00, 0x27, 0xFF, 0xF6, 0xFF, 0xB1, 0xFF, 0x6F, 0xFF, 0x4F, 0xFF, 0x6E, 0xFF, 0xDA, 0x00, 0x82, 0x01, 0x35, 0x01, 0xAB, 0x01, 0x9C, 0x00, 0xDD, 0xFF, 0x7C, 0xFD, 0xCC, 0xFC, 0x5D, 0xFB, 0xDC, 0xFC, 0xDE, 0xFF, 0xAF, 0x04, 0x2B, 0x09, 0xB3, 0x0F, 0x4E, 0x13, 0xDF, 0x16, 0x6F};
const uint8_t FM1[] PROGMEM = {0xFF, 0xFB, 0xFF, 0xFA, 0xFF, 0xFF, 0x00, 0x0B, 0x00, 0x17, 0x00, 0x1A, 0x00, 0x09, 0xFF, 0xE5, 0xFF, 0xC0, 0xFF, 0xB5, 0xFF, 0xDB, 0x00, 0x2F, 0x00, 0x8A, 0x00, 0xAF, 0x00, 0x6C, 0xFF, 0xC4, 0xFF, 0x00, 0xFE, 0x99, 0xFE, 0xF8, 0x00, 0x28, 0x01, 0xB0, 0x02, 0xB0, 0x02, 0x4E, 0x00, 0x44, 0xFD, 0x3A, 0xFA, 0xBA, 0xFA, 0x9D, 0xFE, 0x30, 0x05, 0x6D, 0x0E, 0xBD, 0x17, 0x6B, 0x1C, 0xA6};
const uint8_t FM2[] PROGMEM = {0xFF, 0xFD, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x0E, 0x00, 0x01, 0xFF, 0xE8, 0xFF, 0xD8, 0xFF, 0xEA, 0x00, 0x1F, 0x00, 0x52, 0x00, 0x4B, 0xFF, 0xF5, 0xFF, 0x7F, 0xFF, 0x54, 0xFF, 0xBE, 0x00, 0x95, 0x01, 0x34, 0x00, 0xEB, 0xFF, 0xA6, 0xFE, 0x3C, 0xFD, 0xF5, 0xFF, 0x82, 0x02, 0x1C, 0x03, 0xB7, 0x02, 0x6E, 0xFE, 0x3F, 0xF9, 0xCE, 0xF9, 0x31, 0xFF, 0x57, 0x0B, 0x9F, 0x19, 0x7E, 0x22, 0xA8};
const uint8_t FM3[] PROGMEM = {0x00, 0x02, 0x00, 0x08, 0x00, 0x06, 0xFF, 0xF7, 0xFF, 0xE9, 0xFF, 0xF3, 0x00, 0x19, 0x00, 0x34, 0x00, 0x14, 0xFF, 0xC6, 0xFF, 0x9D, 0xFF, 0xE7, 0x00, 0x75, 0x00, 0xAA, 0x00, 0x15, 0xFF, 0x26, 0xFE, 0xF1, 0x00, 0x04, 0x01, 0x7B, 0x01, 0x9C, 0xFF, 0xBC, 0xFD, 0x7F, 0xFD, 0x9B, 0x00, 0xD2, 0x04, 0x46, 0x03, 0xA6, 0xFD, 0xE5, 0xF7, 0xE3, 0xF9, 0x79, 0x06, 0x7F, 0x19, 0xF6, 0x28, 0x6D};
const uint8_t FM4[] PROGMEM = {0x00, 0x05, 0x00, 0x03, 0xFF, 0xF7, 0xFF, 0xF1, 0x00, 0x04, 0x00, 0x1F, 0x00, 0x12, 0xFF, 0xDB, 0xFF, 0xC5, 0x00, 0x0C, 0x00, 0x65, 0x00, 0x3C, 0xFF, 0x98, 0xFF, 0x59, 0x00, 0x19, 0x00, 0xFF, 0x00, 0x9C, 0xFF, 0x10, 0xFE, 0x77, 0x00, 0x28, 0x02, 0x3A, 0x01, 0x6E, 0xFD, 0xFE, 0xFC, 0x86, 0x00, 0x37, 0x05, 0x22, 0x03, 0xA6, 0xFA, 0xFA, 0xF5, 0xCA, 0x00, 0x40, 0x18, 0xCE, 0x2D, 0xE9};
const uint8_t FM5[] PROGMEM = {0x00, 0x03, 0xFF, 0xFB, 0xFF, 0xF6, 0x00, 0x07, 0x00, 0x16, 0xFF, 0xFC, 0xFF, 0xD7, 0xFF, 0xF7, 0x00, 0x3F, 0x00, 0x27, 0xFF, 0xAD, 0xFF, 0xA7, 0x00, 0x5A, 0x00, 0xA3, 0xFF, 0xBA, 0xFE, 0xFF, 0x00, 0x05, 0x01, 0x68, 0x00, 0x7A, 0xFE, 0x3C, 0xFE, 0xB7, 0x01, 0xF8, 0x02, 0x7A, 0xFE, 0x2A, 0xFB, 0xDC, 0x01, 0x1C, 0x06, 0x85, 0x00, 0xCB, 0xF5, 0x84, 0xF9, 0xF5, 0x16, 0x16, 0x33, 0x13};
const uint8_t FM6[] PROGMEM = {0xFF, 0xFE, 0xFF, 0xF8, 0x00, 0x04, 0x00, 0x10, 0xFF, 0xF7, 0xFF, 0xE3, 0x00, 0x10, 0x00, 0x30, 0xFF, 0xE3, 0xFF, 0xB5, 0x00, 0x2F, 0x00, 0x6F, 0xFF, 0xB7, 0xFF, 0x60, 0x00, 0x6F, 0x00, 0xDF, 0xFF, 0x5C, 0xFE, 0xCF, 0x00, 0xEE, 0x01, 0x9C, 0xFE, 0xAC, 0xFD, 0xD6, 0x01, 0xE7, 0x02, 0xF0, 0xFD, 0x3A, 0xFB, 0xE5, 0x04, 0x3C, 0x06, 0x2E, 0xF8, 0xBF, 0xF4, 0xB6, 0x11, 0xFB, 0x37, 0xE1};
const uint8_t FM7[] PROGMEM = {0xFF, 0xFB, 0x00, 0x00, 0x00, 0x0C, 0xFF, 0xFB, 0xFF, 0xEB, 0x00, 0x13, 0x00, 0x1B, 0xFF, 0xD3, 0xFF, 0xE9, 0x00, 0x52, 0xFF, 0xFF, 0xFF, 0x85, 0x00, 0x38, 0x00, 0x9C, 0xFF, 0x6C, 0xFF, 0x63, 0x01, 0x14, 0x00, 0x66, 0xFE, 0x57, 0x00, 0x28, 0x02, 0x37, 0xFE, 0xD8, 0xFD, 0x72, 0x02, 0xB2, 0x02, 0x6E, 0xFB, 0x16, 0xFE, 0x9A, 0x08, 0x37, 0xFE, 0x67, 0xF1, 0x6A, 0x0C, 0xBF, 0x3C, 0x4A};
const uint8_t FM8[] PROGMEM = {0xFF, 0xFC, 0x00, 0x07, 0x00, 0x01, 0xFF, 0xEF, 0x00, 0x0D, 0x00, 0x12, 0xFF, 0xD9, 0x00, 0x04, 0x00, 0x3D, 0xFF, 0xC6, 0xFF, 0xD4, 0x00, 0x7D, 0xFF, 0xDA, 0xFF, 0x69, 0x00, 0xB3, 0x00, 0x46, 0xFE, 0xCC, 0x00, 0x97, 0x01, 0x30, 0xFE, 0x3C, 0xFF, 0xC9, 0x02, 0x99, 0xFE, 0x34, 0xFD, 0xD9, 0x04, 0x46, 0xFF, 0x8E, 0xFA, 0x13, 0x05, 0xCC, 0x04, 0x97, 0xF0, 0xA5, 0x06, 0xB5, 0x40, 0x48};
const uint8_t FM9[] PROGMEM = {0x00, 0x01, 0x00, 0x06, 0xFF, 0xF5, 0x00, 0x03, 0x00, 0x12, 0xFF, 0xE3, 0x00, 0x07, 0x00, 0x29, 0xFF, 0xC2, 0x00, 0x0C, 0x00, 0x51, 0xFF, 0x8C, 0x00, 0x13, 0x00, 0x93, 0xFF, 0x37, 0x00, 0x1C, 0x00, 0xFB, 0xFE, 0xB5, 0x00, 0x25, 0x01, 0x9C, 0xFD, 0xF0, 0x00, 0x2E, 0x02, 0xA2, 0xFC, 0xAD, 0x00, 0x37, 0x04, 0x80, 0xFA, 0x3C, 0x00, 0x3D, 0x09, 0x3F, 0xF2, 0x87, 0x00, 0x40, 0x43, 0xD2};
const uint8_t FM10[] PROGMEM = {0x00, 0x05, 0xFF, 0xFD, 0xFF, 0xFA, 0x00, 0x11, 0xFF, 0xEF, 0xFF, 0xFD, 0x00, 0x22, 0xFF, 0xCE, 0x00, 0x1A, 0x00, 0x27, 0xFF, 0x9B, 0x00, 0x61, 0x00, 0x00, 0xFF, 0x72, 0x00, 0xD7, 0xFF, 0x87, 0xFF, 0x87, 0x01, 0x5D, 0xFE, 0xA0, 0x00, 0x28, 0x01, 0xA7, 0xFD, 0x55, 0x01, 0xB0, 0x01, 0x2E, 0xFB, 0xDC, 0x04, 0x9E, 0xFE, 0xF4, 0xFA, 0x8D, 0x0A, 0xD0, 0xF6, 0xBD, 0xF9, 0xC7, 0x46, 0xE2};
const uint8_t FM11[] PROGMEM = {0x00, 0x04, 0xFF, 0xF8, 0x00, 0x08, 0xFF, 0xFF, 0xFF, 0xF2, 0x00, 0x1F, 0xFF, 0xDD, 0x00, 0x11, 0x00, 0x19, 0xFF, 0xB5, 0x00, 0x63, 0xFF, 0xBA, 0xFF, 0xED, 0x00, 0x89, 0xFF, 0x25, 0x00, 0xC6, 0xFF, 0xD4, 0xFF, 0x3A, 0x01, 0x9B, 0xFE, 0x3C, 0x00, 0xE9, 0x00, 0xD1, 0xFD, 0x4C, 0x03, 0xAB, 0xFD, 0x3A, 0xFF, 0xC7, 0x04, 0x80, 0xF7, 0xD1, 0x08, 0xC4, 0xFC, 0x8D, 0xF3, 0xB2, 0x49, 0x73};
const uint8_t FM12[] PROGMEM = {0x00, 0x00, 0xFF, 0xFC, 0x00, 0x0A, 0xFF, 0xEF, 0x00, 0x14, 0xFF, 0xF2, 0xFF, 0xFC, 0x00, 0x1F, 0xFF, 0xC2, 0x00, 0x52, 0xFF, 0xB3, 0x00, 0x25, 0x00, 0x26, 0xFF, 0x7C, 0x00, 0xD6, 0xFF, 0x09, 0x00, 0xC4, 0xFF, 0xCF, 0xFF, 0x54, 0x01, 0x9C, 0xFD, 0xB6, 0x02, 0x5C, 0xFE, 0x6D, 0xFF, 0xE4, 0x02, 0x6E, 0xFB, 0x2D, 0x06, 0x7D, 0xF9, 0x85, 0x03, 0xCA, 0x02, 0xF6, 0xEE, 0x63, 0x4B, 0x7F};
const uint8_t FM13[] PROGMEM = {0xFF, 0xFB, 0x00, 0x05, 0xFF, 0xFC, 0xFF, 0xFF, 0x00, 0x0A, 0xFF, 0xE9, 0x00, 0x26, 0xFF, 0xCC, 0x00, 0x3D, 0xFF, 0xC6, 0x00, 0x27, 0xFF, 0xFF, 0xFF, 0xC8, 0x00, 0x7F, 0xFF, 0x38, 0x01, 0x05, 0xFE, 0xDD, 0x01, 0x11, 0xFF, 0x41, 0x00, 0x28, 0x00, 0xAF, 0xFE, 0x4C, 0x02, 0xC5, 0xFC, 0x4D, 0x04, 0x46, 0xFB, 0xC1, 0x03, 0x59, 0xFE, 0xBC, 0xFD, 0x8C, 0x08, 0xDC, 0xEA, 0x2F, 0x4D, 0x05};
const uint8_t FM14[] PROGMEM = {0xFF, 0xFB, 0x00, 0x08, 0xFF, 0xF4, 0x00, 0x11, 0xFF, 0xEA, 0x00, 0x1A, 0xFF, 0xE3, 0x00, 0x1D, 0xFF, 0xE9, 0x00, 0x0C, 0x00, 0x07, 0xFF, 0xDC, 0x00, 0x49, 0xFF, 0x87, 0x00, 0xB1, 0xFF, 0x12, 0x01, 0x2E, 0xFE, 0x94, 0x01, 0xA0, 0xFE, 0x3C, 0x01, 0xD0, 0xFE, 0x47, 0x01, 0x75, 0xFF, 0x07, 0x00, 0x37, 0x00, 0xE4, 0xFD, 0x8F, 0x04, 0xA3, 0xF8, 0x20, 0x0D, 0x3A, 0xE7, 0x5A, 0x4E, 0x00};
const uint8_t FM15[] PROGMEM = {0x00, 0x00, 0x00, 0x01, 0xFF, 0xFE, 0x00, 0x03, 0xFF, 0xFA, 0x00, 0x09, 0xFF, 0xF2, 0x00, 0x14, 0xFF, 0xE4, 0x00, 0x27, 0xFF, 0xCC, 0x00, 0x45, 0xFF, 0xA6, 0x00, 0x73, 0xFF, 0x6E, 0x00, 0xB6, 0xFF, 0x1E, 0x01, 0x16, 0xFE, 0xAD, 0x01, 0x9C, 0xFE, 0x0E, 0x02, 0x59, 0xFD, 0x2C, 0x03, 0x6A, 0xFB, 0xDC, 0x05, 0x12, 0xF9, 0xB3, 0x08, 0x07, 0xF5, 0x56, 0x0F, 0x4E, 0xE6, 0x12, 0x4E, 0x6F};

const uint8_t AM0[] PROGMEM = {0xFF, 0xFE, 0xFF, 0xFB, 0xFF, 0xF7, 0xFF, 0xF1, 0xFF, 0xE9, 0xFF, 0xE0, 0xFF, 0xD5, 0xFF, 0xCA, 0xFF, 0xBE, 0xFF, 0xB5, 0xFF, 0xAF, 0xFF, 0xAF, 0xFF, 0xB6, 0xFF, 0xC8, 0xFF, 0xE7, 0x00, 0x15, 0x00, 0x54, 0x00, 0xA5, 0x01, 0x09, 0x01, 0x7F, 0x02, 0x07, 0x02, 0x9C, 0x03, 0x3E, 0x03, 0xE6, 0x04, 0x90, 0x05, 0x36, 0x05, 0xD3, 0x06, 0x61, 0x06, 0xDA, 0x07, 0x39, 0x07, 0x7B, 0x07, 0x9C};
const uint8_t AM1[] PROGMEM = {0x00, 0x02, 0x00, 0x01, 0xFF, 0xFF, 0xFF, 0xFB, 0xFF, 0xF5, 0xFF, 0xEB, 0xFF, 0xDE, 0xFF, 0xCF, 0xFF, 0xBD, 0xFF, 0xA9, 0xFF, 0x97, 0xFF, 0x87, 0xFF, 0x7D, 0xFF, 0x7D, 0xFF, 0x89, 0xFF, 0xA6, 0xFF, 0xD8, 0x00, 0x20, 0x00, 0x81, 0x00, 0xFC, 0x01, 0x91, 0x02, 0x3C, 0x02, 0xFA, 0x03, 0xC7, 0x04, 0x9A, 0x05, 0x6D, 0x06, 0x37, 0x06, 0xF0, 0x07, 0x90, 0x08, 0x0E, 0x08, 0x66, 0x08, 0x93};
const uint8_t AM2[] PROGMEM = {0x00, 0x05, 0x00, 0x07, 0x00, 0x09, 0x00, 0x09, 0x00, 0x07, 0x00, 0x02, 0xFF, 0xF8, 0xFF, 0xE9, 0xFF, 0xD5, 0xFF, 0xBC, 0xFF, 0x9E, 0xFF, 0x7F, 0xFF, 0x61, 0xFF, 0x49, 0xFF, 0x3B, 0xFF, 0x3D, 0xFF, 0x54, 0xFF, 0x87, 0xFF, 0xDA, 0x00, 0x50, 0x00, 0xE9, 0x01, 0xA6, 0x02, 0x82, 0x03, 0x77, 0x04, 0x7D, 0x05, 0x89, 0x06, 0x8F, 0x07, 0x82, 0x08, 0x57, 0x09, 0x01, 0x09, 0x78, 0x09, 0xB6};
const uint8_t AM3[] PROGMEM = {0x00, 0x04, 0x00, 0x08, 0x00, 0x0C, 0x00, 0x12, 0x00, 0x16, 0x00, 0x1A, 0x00, 0x19, 0x00, 0x13, 0x00, 0x06, 0xFF, 0xF0, 0xFF, 0xD1, 0xFF, 0xA9, 0xFF, 0x7A, 0xFF, 0x49, 0xFF, 0x1B, 0xFE, 0xF7, 0xFE, 0xE7, 0xFE, 0xF2, 0xFF, 0x22, 0xFF, 0x7F, 0x00, 0x0D, 0x00, 0xCE, 0x01, 0xC1, 0x02, 0xDF, 0x04, 0x1E, 0x05, 0x70, 0x06, 0xC3, 0x08, 0x06, 0x09, 0x24, 0x0A, 0x0D, 0x0A, 0xB1, 0x0B, 0x06};
const uint8_t AM4[] PROGMEM = {0xFF, 0xFF, 0x00, 0x00, 0x00, 0x04, 0x00, 0x0B, 0x00, 0x14, 0x00, 0x1F, 0x00, 0x2B, 0x00, 0x34, 0x00, 0x38, 0x00, 0x34, 0x00, 0x23, 0x00, 0x03, 0xFF, 0xD3, 0xFF, 0x94, 0xFF, 0x4C, 0xFF, 0x01, 0xFE, 0xBE, 0xFE, 0x90, 0xFE, 0x85, 0xFE, 0xAD, 0xFF, 0x13, 0xFF, 0xBF, 0x00, 0xB5, 0x01, 0xF1, 0x03, 0x68, 0x05, 0x09, 0x06, 0xBC, 0x08, 0x65, 0x09, 0xE6, 0x0B, 0x25, 0x0C, 0x08, 0x0C, 0x7E};
const uint8_t AM5[] PROGMEM = {0xFF, 0xFB, 0xFF, 0xF8, 0xFF, 0xF6, 0xFF, 0xF7, 0xFF, 0xFC, 0x00, 0x06, 0x00, 0x16, 0x00, 0x2B, 0x00, 0x42, 0x00, 0x57, 0x00, 0x65, 0x00, 0x64, 0x00, 0x4F, 0x00, 0x20, 0xFF, 0xD7, 0xFF, 0x76, 0xFF, 0x07, 0xFE, 0x99, 0xFE, 0x40, 0xFE, 0x13, 0xFE, 0x2A, 0xFE, 0x98, 0xFF, 0x6C, 0x00, 0xAB, 0x02, 0x4C, 0x04, 0x3E, 0x06, 0x60, 0x08, 0x8A, 0x0A, 0x90, 0x0C, 0x45, 0x0D, 0x82, 0x0E, 0x27};
const uint8_t AM6[] PROGMEM = {0xFF, 0xFF, 0xFF, 0xFC, 0xFF, 0xF6, 0xFF, 0xEF, 0xFF, 0xE8, 0xFF, 0xE3, 0xFF, 0xE6, 0xFF, 0xF2, 0x00, 0x09, 0x00, 0x2C, 0x00, 0x56, 0x00, 0x80, 0x00, 0x9F, 0x00, 0xA6, 0x00, 0x8A, 0x00, 0x42, 0xFF, 0xCF, 0xFF, 0x39, 0xFE, 0x95, 0xFE, 0x00, 0xFD, 0x9F, 0xFD, 0x99, 0xFE, 0x11, 0xFF, 0x1E, 0x00, 0xC5, 0x02, 0xF8, 0x05, 0x92, 0x08, 0x5C, 0x0B, 0x11, 0x0D, 0x6A, 0x0F, 0x25, 0x10, 0x10};
const uint8_t AM7[] PROGMEM = {0x00, 0x05, 0x00, 0x08, 0x00, 0x08, 0x00, 0x04, 0xFF, 0xFA, 0xFF, 0xEB, 0xFF, 0xD9, 0xFF, 0xC8, 0xFF, 0xC1, 0xFF, 0xCA, 0xFF, 0xE8, 0x00, 0x1E, 0x00, 0x65, 0x00, 0xAF, 0x00, 0xE8, 0x00, 0xF9, 0x00, 0xCB, 0x00, 0x56, 0xFF, 0x9C, 0xFE, 0xB7, 0xFD, 0xD2, 0xFD, 0x2A, 0xFC, 0xFD, 0xFD, 0x87, 0xFE, 0xEC, 0x01, 0x31, 0x04, 0x35, 0x07, 0xB2, 0x0B, 0x45, 0x0E, 0x7C, 0x10, 0xEA, 0x12, 0x38};
const uint8_t AM8[] PROGMEM = {0xFF, 0xFE, 0x00, 0x02, 0x00, 0x08, 0x00, 0x11, 0x00, 0x19, 0x00, 0x1A, 0x00, 0x11, 0xFF, 0xFA, 0xFF, 0xD7, 0xFF, 0xB0, 0xFF, 0x93, 0xFF, 0x8F, 0xFF, 0xB3, 0x00, 0x02, 0x00, 0x74, 0x00, 0xEE, 0x01, 0x48, 0x01, 0x58, 0x00, 0xFD, 0x00, 0x2C, 0xFE, 0xFF, 0xFD, 0xB5, 0xFC, 0xAE, 0xFC, 0x53, 0xFD, 0x06, 0xFE, 0xFE, 0x02, 0x36, 0x06, 0x65, 0x0B, 0x03, 0x0F, 0x5F, 0x12, 0xC6, 0x14, 0xA3};
const uint8_t AM9[] PROGMEM = {0xFF, 0xFD, 0xFF, 0xF8, 0xFF, 0xF4, 0xFF, 0xF4, 0xFF, 0xFC, 0x00, 0x0E, 0x00, 0x25, 0x00, 0x38, 0x00, 0x3C, 0x00, 0x24, 0xFF, 0xEE, 0xFF, 0xA5, 0xFF, 0x62, 0xFF, 0x45, 0xFF, 0x6C, 0xFF, 0xE4, 0x00, 0x98, 0x01, 0x53, 0x01, 0xCA, 0x01, 0xB1, 0x00, 0xDE, 0xFF, 0x63, 0xFD, 0x99, 0xFC, 0x19, 0xFB, 0x96, 0xFC, 0xAA, 0xFF, 0xA3, 0x04, 0x57, 0x0A, 0x20, 0x0F, 0xFA, 0x14, 0xBD, 0x17, 0x69};
const uint8_t AM10[] PROGMEM = {0x00, 0x06, 0x00, 0x08, 0x00, 0x06, 0xFF, 0xFC, 0xFF, 0xED, 0xFF, 0xDE, 0xFF, 0xDB, 0xFF, 0xEE, 0x00, 0x17, 0x00, 0x4B, 0x00, 0x70, 0x00, 0x67, 0x00, 0x21, 0xFF, 0xA8, 0xFF, 0x2A, 0xFE, 0xE9, 0xFF, 0x21, 0xFF, 0xE3, 0x00, 0xFE, 0x02, 0x01, 0x02, 0x5D, 0x01, 0xA7, 0xFF, 0xD4, 0xFD, 0x64, 0xFB, 0x52, 0xFA, 0xCA, 0xFC, 0xBD, 0x01, 0x77, 0x08, 0x62, 0x10, 0x15, 0x16, 0xB6, 0x1A, 0x8B};
const uint8_t AM11[] PROGMEM = {0xFF, 0xFA, 0xFF, 0xFB, 0x00, 0x01, 0x00, 0x0E, 0x00, 0x1A, 0x00, 0x19, 0x00, 0x04, 0xFF, 0xDC, 0xFF, 0xB7, 0xFF, 0xB3, 0xFF, 0xE3, 0x00, 0x41, 0x00, 0x9F, 0x00, 0xBB, 0x00, 0x66, 0xFF, 0xA8, 0xFE, 0xD8, 0xFE, 0x78, 0xFE, 0xF2, 0x00, 0x49, 0x01, 0xF0, 0x02, 0xF6, 0x02, 0x77, 0x00, 0x33, 0xFC, 0xE6, 0xFA, 0x38, 0xFA, 0x1D, 0xFD, 0xEB, 0x05, 0x97, 0x0F, 0x6E, 0x18, 0x95, 0x1E, 0x17};
const uint8_t AM12[] PROGMEM = {0x00, 0x06, 0x00, 0x05, 0xFF, 0xFC, 0xFF, 0xEE, 0xFF, 0xE8, 0xFF, 0xF5, 0x00, 0x17, 0x00, 0x3A, 0x00, 0x3D, 0x00, 0x09, 0xFF, 0xB1, 0xFF, 0x72, 0xFF, 0x8E, 0x00, 0x1A, 0x00, 0xCC, 0x01, 0x1F, 0x00, 0xA6, 0xFF, 0x75, 0xFE, 0x40, 0xFE, 0x03, 0xFF, 0x4B, 0x01, 0x9E, 0x03, 0x82, 0x03, 0x4A, 0x00, 0x50, 0xFB, 0xD3, 0xF8, 0xBB, 0xFA, 0x2F, 0x01, 0xAB, 0x0D, 0xBA, 0x1A, 0x37, 0x22, 0x24};
const uint8_t AM13[] PROGMEM = {0xFF, 0xFA, 0xFF, 0xF9, 0x00, 0x01, 0x00, 0x11, 0x00, 0x19, 0x00, 0x06, 0xFF, 0xDE, 0xFF, 0xC3, 0xFF, 0xDE, 0x00, 0x2F, 0x00, 0x78, 0x00, 0x63, 0xFF, 0xD9, 0xFF, 0x3A, 0xFF, 0x26, 0xFF, 0xED, 0x01, 0x19, 0x01, 0x9A, 0x00, 0xA9, 0xFE, 0xB1, 0xFD, 0x53, 0xFE, 0x28, 0x01, 0x2B, 0x04, 0x25, 0x04, 0x15, 0xFF, 0xCF, 0xF9, 0xC6, 0xF7, 0x3A, 0xFC, 0xC5, 0x0A, 0x99, 0x1B, 0x56, 0x26, 0xBD};
const uint8_t AM14[] PROGMEM = {0x00, 0x03, 0x00, 0x0A, 0x00, 0x08, 0xFF, 0xF5, 0xFF, 0xE3, 0xFF, 0xF0, 0x00, 0x1E, 0x00, 0x40, 0x00, 0x1A, 0xFF, 0xBA, 0xFF, 0x86, 0xFF, 0xDE, 0x00, 0x8E, 0x00, 0xD2, 0x00, 0x20, 0xFE, 0xFA, 0xFE, 0xAF, 0xFF, 0xF8, 0x01, 0xC9, 0x02, 0x03, 0xFF, 0xC6, 0xFC, 0xFE, 0xFC, 0xFB, 0x00, 0xCB, 0x05, 0x1C, 0x04, 0xAF, 0xFD, 0xFC, 0xF6, 0x86, 0xF7, 0x84, 0x05, 0xB5, 0x1B, 0x94, 0x2B, 0xFD};

const uint8_t* const FIR_table[] = {FM0, FM1, FM2, FM3, FM4, FM5, FM6, FM7, FM8, FM9, FM10, FM11, FM12, FM13, FM14, FM15, AM0, AM1, AM2, AM3, AM4, AM5, AM6, AM7, AM8, AM9, AM10, AM11, AM12, AM13, AM14};

uint8_t default_FIR_table[2][16] =
{
   {24, 0, 26, 1, 28, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}, // FM 
   {29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29} // AM (?)
};

TwiMaster xdr(false);

void serialHex(uint8_t);
void deemphasis(uint8_t);
void coeff(int, int);
void FIR(int8_t);
void tune();
void RDS();
uint8_t querySAF(uint8_t, uint8_t, uint8_t);
void spectrumUsage(int, long, long);
void align(long);

void setup(void)
{
  pinMode(RDS_PIN, INPUT);
  pinMode(SDA_PIN, INPUT);
  pinMode(SCL_PIN, INPUT);
  pinMode(RESET_PIN, INPUT);
  Serial.begin(115200);
  
  while(!(Serial.available()>0)); // wait for any data on serial before starting up
  
  // IR power up & FM band
  IRsend irsend;
  for (int i=0; i<3; i++)
  {
    irsend.sendSony(0xA8BC8, 20); // POWER
    delay(75);
  }
  delay(5500);
/*  for (int i=0; i<3; i++)
  {
    irsend.sendSony(0xF6BC8, 20); // BAND
    delay(75);
  }
  delay(3000);*/

  pinMode(RESET_PIN, OUTPUT);
  digitalWrite(RESET_PIN, HIGH);
  delay(100);
  
  pinMode(SDA_PIN, OUTPUT);
  pinMode(SCL_PIN, OUTPUT);
  digitalWrite(SDA_PIN, HIGH);
  digitalWrite(SCL_PIN, HIGH);
  
  goFM();
  
  // write the FIR coefficients
  FIR(-1);
  
  // RDS settings
  xdr.start(0x38 | I2C_WRITE);
  xdr.write(0x00); 
  xdr.write(0x00); 
  xdr.write(0x34);     
    xdr.write(0x30); // sync mode - max 2 bits error correctable
    xdr.write(0x20); // blocks are handled as vaild
  xdr.stop();
  
  deemphasis(0); // set 50us de-emphasis as default
  
  Serial.println("XDR-F1HD controller is ready.");
  while(Serial.available()>0)
    Serial.read(); // clear the serial buffer
}

void loop()
{
    if(!digitalRead(RDS_PIN))
      RDS();
      
    if(Serial.available() > 0)
    {
      char action, buff[20];
      action = Serial.read();
  
      unsigned int tmp, i=0;
      while(1)
      {
        if (Serial.available() > 0)
        {
          buff[i] = Serial.read();
          if(buff[i] == 0x0A||i==19)
          {
            buff[i] = 0x00;
            break;
          }
          i++;
        }
      }

      switch (action)
      {
        case 'T': // frequency change ***Modified by F4CMB***
        {
          long freq = atol(buff);
 
          if ((freq>=60000) && (freq<=137000)) //FM BAND
          {
            if(freq % 50)
            {
              tmp = ((freq+10700)*2)/10;
              BAND = B00110001; // 5kHz step, fref=10kHz
            } 
            else
            {
              // we use 50kHz step if possible, because
              // in other cases the audio output isn't clear
              tmp = ((freq+10700)*2)/100;
              BAND = B00100001; // 50kHz step, fref=100kHz
            }
          }
  /*        if ((freq>=76000) && (freq<=87499)) //JAPAN BAND
          {
            BAND = B01000011;
            tmp=((freq-10700)*3)/100;
          }
          if ((freq>=60000) && (freq<=75999)) //OIRT BAND
          {
            BAND = B01001111;
            tmp=((freq-10700)*3)/20;
          }
          if ((freq>=108050) && (freq<=137000)) //AIR BAND (customized mode)
          {
            BAND = B00100001;
            tmp=((freq+10700)*2)/100;
          } */
          if ((freq>=137000) && (freq<=200000)) //WB BAND
          {
             BAND = B00001001;
            tmp=((freq+10700)*1)/25;
          }
          if ((freq>=100) && (freq<=1900)) //LW & MW BAND
          {
            BAND = B11101101;
            tmp=((freq+10700)*20)/20;
          }
          if ((freq>=1901) && (freq<=5899)) // AM SW 120m to 60m
          {
            BAND = B11010001;
            tmp=((freq+10700)*16)/10;
          }    
          if ((freq>=5900) && (freq<=13870)) // AM SW 49m to 22m
          {
            BAND = B10110001;
            tmp=((freq+10700)*10)/10;
          }
          if ((freq>=13871) && (freq<=19020)) // AM SW 25m to 15m
          {
            BAND = B10010001;
            tmp=((freq+10700)*8)/10;
          }
          if ((freq>=19021) && (freq<=30000)) // AM SW 16m to 11m
          {
            BAND = B01110001;
            tmp=((freq+10700)*6)/10;
          }

          PLLM = tmp>>8 & 0xFF;
          PLLL = tmp&0xFF;

          align(freq);  
          tune();
          Serial.print("T");
          serialHex(PLLM);
          serialHex(PLLL);
          serialHex(AGC);
          serialHex(BAND);
          Serial.println();
        }
        break;

        case 'A': // RF AGC threshold voltage
          tmp = atoi(buff);
          switch (tmp)
          {
             case 0: AGC &= B11110011; break; // 00 24mV
             case 1: AGC &= B11110111;
                     AGC |= B00000100; break; // 01 17mV
             case 2: AGC |= B00001000;
                     AGC &= B11111011; break; // 10 12mV
             case 3: AGC |= B00001100; break; // 11 9mV
          }  
          tune();   
       break;

       case 'V': // set 1st antenna circuit tuning voltage
         DAA = atoi(buff) & 0x7F; // 0...127 -> 0.1...2.0V
         tune();   
       break;
  
       case 'F': // change FIR filters (takes about 100ms with 400kHz I2C)
         tmp = atoi(buff);
         FIR(tmp);
         Serial.print("F");
         Serial.println(tmp);
       break;
       
       case 'D': // change the de-emphasis
         tmp = atoi(buff);
         deemphasis(tmp);
         Serial.print("D");
         Serial.println(tmp);
       break;
       
       case 'M': // change the mode (added by F4CMB)
         tmp = atoi(buff);
         switch (tmp)
          {
             case 1: goFM(); break;
             case 2: goAM(); break;
//           case 3: goNFM();break;
          }  
          tune();   
       break;
       
       case 'G': // RF/IF Gain
         if(buff[0] == '1') // FM RF +6dB gain
           CONTROL |= B10000000;
         else // FM RF standard gain
           CONTROL &= B01111111;
         
         if(buff[1] == '1') // IF +6dB gain
           CONTROL |= B00010000;
         else // IF standard gain
           CONTROL &= B11101111;
         tune();
       break;
       
       case 'U': // spectrum usage (Us,x,y)
       // reads signal levels from x to y frequency with s step
       // example: U100,87500,108000  for CCIR
       //          U30,65900,73970    for OIRT
       {
         long data[3];
         int num=0, pos=0;
         char buff2[7];
         for(int i=0; i<=strlen(buff); i++)
         {
           if(buff[i] != ',' && buff[i] != 0x00)
           {
             buff2[pos] = buff[i];
             pos++;
           }
           else
           {
             buff2[pos] = 0x00;
             pos=0;
             data[num]=atol(buff2);
             num++;
           }
         } 
         Serial.print("U");
         spectrumUsage(data[0], data[1], data[2]);
       }
       break;
       
       case 'X': // shutdown
         TWCR = 0; // release SDA and SCL lines used by hardware I2C
         digitalWrite(RESET_PIN, LOW);
         pinMode(RESET_PIN, INPUT);
         Serial.println("X");
         asm("jmp 0");
       break;
       
      }
    }

    // request signal level 10 times per second
    if((millis()-timer) >= 100)
    {
      Serial.print("S");
      Serial.println(querySAF(0x03, 0x00, ((mode==1)?0x92:0x6E)), DEC);
      timer = millis();
    }    
    
}

void serialHex(uint8_t val)
{
  Serial.print(val >>  4 & 0x0F, HEX);
  Serial.print(val >>  0 & 0x0F, HEX);
}

void deemphasis(uint8_t d)
{
  xdr.start(0x38 | I2C_WRITE);
  xdr.write(0x03);
  xdr.write(0x11);
  xdr.write(0xD7);
  switch (d)
  {
    case 0: // 50us
      xdr.write(0x02); xdr.write(0xC0); xdr.write(0x04); xdr.write(0xE4); xdr.write(0x00); xdr.write(0x85);
    break;
    case 1: // 75us
      xdr.write(0x01); xdr.write(0xF6); xdr.write(0x05); xdr.write(0xC3); xdr.write(0x00); xdr.write(0x85);
    break;
    case 2: // none
      xdr.write(0x07); xdr.write(0xFF); xdr.write(0x00); xdr.write(0x00); xdr.write(0x00); xdr.write(0x00);
    break;
  }
  xdr.stop();
}

void coeff(int num, int fir)
{ 
  uint8_t addr[2];
  int address = 0x0C00 + 32 * num;
  int i = 0;
  while(i<64)
  {
    addr[0] = address>>8 & 0xFF;
    addr[1] = address & 0xFF;
    xdr.start(0x38 | I2C_WRITE);
      xdr.write(0x01);
      xdr.write(addr[0]);
      xdr.write(addr[1]);
      xdr.write(pgm_read_byte_near(FIR_table[fir]+(i++)));
      xdr.write(pgm_read_byte_near(FIR_table[fir]+(i++)));
      xdr.write(0x00);
    xdr.stop();
    address++;
  }
}

void FIR(int8_t f)
{
  if(f >= 0 && f <= 30)
  {
    // fixed filter bandwidth
    // write the same FIR into each memory bank
    for(int i=0; i<16; i++)
      coeff(i, f);
  }
  else
  {
    // adaptive filter bandwidth
    for(int i=0; i<16; i++)
      coeff(i, default_FIR_table[(mode-1)][i]);
  }
}

void tune() 
{
  xdr.start(0x38 | I2C_WRITE);
    xdr.write(0x00);
    xdr.write(0xFF);
    xdr.write(0xFF);
  xdr.restart(0xC4 | I2C_WRITE);
    xdr.write(0x80);
    xdr.write(CONTROL);
    xdr.write(PLLM);
    xdr.write(PLLL);
    xdr.write(DAA);
    xdr.write(AGC);
    xdr.write(BAND);
  xdr.stop();
  
  // reset the RDS synchronization
  xdr.start(0x38 | I2C_WRITE);
  xdr.write(0x00); 
  xdr.write(0x00); 
  xdr.write(0x35);     
    xdr.write(0x00);     
    xdr.write(0x20);
  xdr.stop();
  
  pi_buffer[0]=0x00;
  pi_buffer[1]=0x00;
  pi_ok_buffer[0]=0x00;
  pi_ok_buffer[1]=0x00;
}

void goAM() //added by F4CMB
{
  xdr.start(0x38 | I2C_WRITE);     // set device address and write mode
  xdr.write(0x0D);
  xdr.write(0x14);
  xdr.write(0x89);
  xdr.write(0x02);
  xdr.write(0x00);
  xdr.stop();
  xdr.start(0x38 | I2C_WRITE);
  xdr.write(0x01);
  xdr.write(0x00);
  xdr.write(0x01);
  xdr.write(0x00);
  xdr.write(0x00);
  xdr.write(0x51);
  xdr.stop();
  xdr.start(0x38 | I2C_WRITE);
  xdr.write(0x05);
  xdr.write(0x0F);
  xdr.write(0xF9);
  xdr.write(0x00);
  xdr.write(0x00);
  xdr.write(0x1F);
  xdr.stop();
  xdr.start(0x38 | I2C_WRITE);
  xdr.write(0x05);
  xdr.write(0x10);
  xdr.write(0x41);
  xdr.write(0x00);
  xdr.write(0x02);
  xdr.stop();
  xdr.start(0x38 | I2C_WRITE);
  xdr.write(0x01);
  xdr.write(0x00);
  xdr.write(0xE7);
  xdr.write(0x00);
  xdr.write(0x00);
  xdr.write(0x01);
  xdr.stop();
  xdr.start(0x38 | I2C_WRITE); 
  xdr.write(0x01);
  xdr.write(0x00);
  xdr.write(0xE8);
  xdr.write(0x00);
  xdr.write(0x00);
  xdr.write(0x02);
  xdr.stop();
  xdr.start(0x38 | I2C_WRITE);
  xdr.write(0x05);
  xdr.write(0x02);
  xdr.write(0x1B);
  xdr.write(0x00);
  xdr.write(0x00);
  xdr.write(0x01);
  xdr.stop();
  xdr.start(0x38 | I2C_WRITE);
  xdr.write(0x05);
  xdr.write(0x02);
  xdr.write(0x1C);
  xdr.write(0x00);
  xdr.write(0x00);
  xdr.write(0x02);
  xdr.stop();
  xdr.start(0x38 | I2C_WRITE); 
  xdr.write(0x03);
  xdr.write(0x11);
  xdr.write(0xF6);
  xdr.write(0x00);
  xdr.write(0xE9);
  xdr.stop();
  xdr.start(0x38 | I2C_WRITE);
  xdr.write(0x03);
  xdr.write(0x10);
  xdr.write(0x2E);
  xdr.write(0x07);
  xdr.write(0xFF);
  xdr.stop();
  xdr.start(0x38 | I2C_WRITE); 
  xdr.write(0x0D);
  xdr.write(0x00);
  xdr.write(0x00);
  xdr.write(0x00);
  xdr.write(0x00);
  xdr.write(0xC6);
  xdr.stop();
  xdr.start(0x38 | I2C_WRITE);; 
  xdr.write(0x0D);
  xdr.write(0x00);
  xdr.write(0x01);
  xdr.write(0x00);
  xdr.write(0x00);
  xdr.write(0xC7);
  xdr.stop();
  xdr.start(0x38 | I2C_WRITE); 
  xdr.write(0x0D);
  xdr.write(0x00);
  xdr.write(0xC4);
  xdr.write(0x00);
  xdr.write(0x00);
  xdr.write(0x03);
  xdr.stop();
  xdr.start(0x38 | I2C_WRITE);  
  xdr.write(0x03);
  xdr.write(0x00);
  xdr.write(0x06);
  xdr.write(0x00);
  xdr.write(0x00);
  xdr.write(0x3C);
  xdr.stop();
  xdr.start(0x38 | I2C_WRITE); 
  xdr.write(0x03);
  xdr.write(0x00);
  xdr.write(0x07);
  xdr.write(0x00);
  xdr.write(0x00);
  xdr.write(0x3D);
  xdr.stop();
  xdr.start(0x38 | I2C_WRITE);  
  xdr.write(0x09);
  xdr.write(0x01);
  xdr.write(0x2E);
  xdr.write(0x00);
  xdr.write(0x02);
  xdr.write(0x1A);
  xdr.stop();
  xdr.start(0x38 | I2C_WRITE);  
  xdr.write(0x01);
  xdr.write(0x0F);
  xdr.write(0xF5);
  xdr.write(0xE2);
  xdr.write(0x76);
  xdr.write(0x28);
  xdr.stop();
  xdr.start(0x38 | I2C_WRITE);  
  xdr.write(0x05);
  xdr.write(0x0F);
  xdr.write(0xF5);
  xdr.write(0xE2);
  xdr.write(0x75);
  xdr.write(0xC1);
  xdr.stop();
  xdr.start(0x38 | I2C_WRITE);  
  xdr.write(0x03);
  xdr.write(0x11);
  xdr.write(0x27);
  xdr.write(0x0F);
  xdr.write(0xEC);
  xdr.stop();
  xdr.start(0x38 | I2C_WRITE);  
  xdr.write(0x03);
  xdr.write(0x10);
  xdr.write(0x11);
  xdr.write(0x07);
  xdr.write(0x21);
  xdr.stop();
  mode = 2;
  FIR(-1);
}

void goFM() // added by F4CMB
{
  xdr.start(0x38 | I2C_WRITE);
  xdr.write(0x0D);
  xdr.write(0x14);
  xdr.write(0x89);
  xdr.write(0x02);
  xdr.write(0x00);
  xdr.stop();
  xdr.start(0x38 | I2C_WRITE);
  xdr.write(0x0D);
  xdr.write(0x14);
  xdr.write(0x88);
  xdr.write(0x05);
  xdr.write(0x73);
  xdr.stop();
  xdr.start(0x38 | I2C_WRITE);
  xdr.write(0x03);
  xdr.write(0x11);
  xdr.write(0xF7);
  xdr.write(0x0F);
  xdr.write(0xC0);
  xdr.stop();
  xdr.start(0x38 | I2C_WRITE);
  xdr.write(0x01);
  xdr.write(0x00);
  xdr.write(0x01);
  xdr.write(0x00);
  xdr.write(0x00);
  xdr.write(0x52);
  xdr.stop();
  xdr.start(0x38 | I2C_WRITE);
  xdr.write(0x05);
  xdr.write(0x0F);
  xdr.write(0xF1);
  xdr.write(0xB1);
  xdr.write(0x10);
  xdr.write(0x40);
  xdr.stop();
  xdr.start(0x38 | I2C_WRITE);
  xdr.write(0x05);
  xdr.write(0x10);
  xdr.write(0x41);
  xdr.write(0x00);
  xdr.write(0x02);
  xdr.stop();
  xdr.start(0x38 | I2C_WRITE);
  xdr.write(0x01);
  xdr.write(0x10);
  xdr.write(0x6C);
  xdr.write(0x07);
  xdr.write(0xFF);
  xdr.stop();
  xdr.start(0x38 | I2C_WRITE);
  xdr.write(0x01);
  xdr.write(0x10);
  xdr.write(0x6D);
  xdr.write(0x0F);
  xdr.write(0x6B);
  xdr.stop();
  xdr.start(0x38 | I2C_WRITE);
  xdr.write(0x01);
  xdr.write(0x10);
  xdr.write(0x6E);
  xdr.write(0x00);
  xdr.write(0x00);
  xdr.stop();
  xdr.start(0x38 | I2C_WRITE);
  xdr.write(0x01);
  xdr.write(0x10);
  xdr.write(0x6F);
  xdr.write(0x04);
  xdr.write(0x00);
  xdr.stop();
  xdr.start(0x38 | I2C_WRITE);
  xdr.write(0x01);
  xdr.write(0x10);
  xdr.write(0x70);
  xdr.write(0x01);
  xdr.write(0x9A);
  xdr.stop();
  xdr.start(0x38 | I2C_WRITE);
  xdr.write(0x01);
  xdr.write(0x10);
  xdr.write(0x71);
  xdr.write(0x00);
  xdr.write(0x00);
  xdr.stop();
  xdr.start(0x38 | I2C_WRITE);
  xdr.write(0x01);
  xdr.write(0x10);
  xdr.write(0x76);
  xdr.write(0x00);
  xdr.write(0x03);
  xdr.stop();
  xdr.start(0x38 | I2C_WRITE);
  xdr.write(0x01);
  xdr.write(0x10);
  xdr.write(0x77);
  xdr.write(0x00);
  xdr.write(0x00);
  xdr.stop();
  xdr.start(0x38 | I2C_WRITE);
  xdr.write(0x01);
  xdr.write(0x10);
  xdr.write(0x78);
  xdr.write(0x00);
  xdr.write(0x02);
  xdr.stop();
  xdr.start(0x38 | I2C_WRITE);
  xdr.write(0x01);
  xdr.write(0x10);
  xdr.write(0x79);
  xdr.write(0x00);
  xdr.write(0x03);
  xdr.stop();
  xdr.start(0x38 | I2C_WRITE);
  xdr.write(0x01);
  xdr.write(0x10);
  xdr.write(0x7F);
  xdr.write(0x00);
  xdr.write(0x00);
  xdr.stop();
  xdr.start(0x38 | I2C_WRITE);
  xdr.write(0x01);
  xdr.write(0x01);
  xdr.write(0xAD);
  xdr.write(0x0F);
  xdr.write(0xC0);
  xdr.write(0xFC);
  xdr.stop();
  xdr.start(0x38 | I2C_WRITE);
  xdr.write(0x01);
  xdr.write(0x01);
  xdr.write(0xAF);
  xdr.write(0x00);
  xdr.write(0x00);
  xdr.write(0x00);
  xdr.stop();
  xdr.start(0x38 | I2C_WRITE);
  xdr.write(0x05);
  xdr.write(0x00);
  xdr.write(0x67);
  xdr.write(0x00);
  xdr.write(0x00);
  xdr.write(0x0C);
  xdr.stop();
//  xdr.start(0x38 | I2C_WRITE); // 75 uS deamphasis
//  xdr.write(0x03);
//  xdr.write(0x11);
//  xdr.write(0xD7);
//  xdr.write(0x01);
//  xdr.write(0xF6);
//  xdr.write(0x05);
//  xdr.write(0xC3);
//  xdr.write(0x00);
//  xdr.write(0x85);
//  xdr.stop();
  xdr.start(0x38 | I2C_WRITE);
  xdr.write(0x03);
  xdr.write(0x11);
  xdr.write(0xF6);
  xdr.write(0x00);
  xdr.write(0xE9);
  xdr.stop();
  xdr.start(0x38 | I2C_WRITE);
  xdr.write(0x03);
  xdr.write(0x10);
  xdr.write(0x2E);
  xdr.write(0x00);
  xdr.write(0x00);
  xdr.stop();
  xdr.start(0x38 | I2C_WRITE);
  xdr.write(0x0D);
  xdr.write(0x00);
  xdr.write(0x00);
  xdr.write(0x00);
  xdr.write(0x00);
  xdr.write(0xC6);
  xdr.stop();
  xdr.start(0x38 | I2C_WRITE);
  xdr.write(0x0D);
  xdr.write(0x00);
  xdr.write(0x01);
  xdr.write(0x00);
  xdr.write(0x00);
  xdr.write(0xC7);
  xdr.stop();
  xdr.start(0x38 | I2C_WRITE);
  xdr.write(0x0D);
  xdr.write(0x00);
  xdr.write(0xC4);
  xdr.write(0x00);
  xdr.write(0x00);
  xdr.write(0x41);
  xdr.stop();
  xdr.start(0x38 | I2C_WRITE);
  xdr.write(0x03);
  xdr.write(0x00);
  xdr.write(0x06);
  xdr.write(0x00);
  xdr.write(0x00);
  xdr.write(0x38);
  xdr.stop();
  xdr.start(0x38 | I2C_WRITE);
  xdr.write(0x03);
  xdr.write(0x00);
  xdr.write(0x07);
  xdr.write(0x00);
  xdr.write(0x00);
  xdr.write(0x39);
  xdr.stop();
  xdr.start(0x38 | I2C_WRITE);
  xdr.write(0x03);
  xdr.write(0x00);
  xdr.write(0x08);
  xdr.write(0x00);
  xdr.write(0x00);
  xdr.write(0x3A);
  xdr.stop();
  xdr.start(0x38 | I2C_WRITE);
  xdr.write(0x03);
  xdr.write(0x00);
  xdr.write(0x09);
  xdr.write(0x00);
  xdr.write(0x00);
  xdr.write(0x3B);
  xdr.stop();
  xdr.start(0x38 | I2C_WRITE);
  xdr.write(0x09);
  xdr.write(0x01);
  xdr.write(0x2E);
  xdr.write(0x00);
  xdr.write(0x01);
  xdr.write(0x37);
  xdr.stop();
  xdr.start(0x38 | I2C_WRITE);
  xdr.write(0x01);
  xdr.write(0x0F);
  xdr.write(0xF5);
  xdr.write(0xE2);
  xdr.write(0x76);
  xdr.write(0x28);
  xdr.stop();
  xdr.start(0x38 | I2C_WRITE);
  xdr.write(0x05);
  xdr.write(0x0F);
  xdr.write(0xF5);
  xdr.write(0xE2);
  xdr.write(0x50);
  xdr.write(0x8D);
  xdr.stop();
  xdr.start(0x38 | I2C_WRITE);
  xdr.write(0x05);
  xdr.write(0x0F);
  xdr.write(0xF9);
  xdr.write(0x00);
  xdr.write(0x00);
  xdr.write(0x17);
  xdr.stop();
  xdr.start(0x38 | I2C_WRITE);
  xdr.write(0x03);
  xdr.write(0x10);
  xdr.write(0x11);
  xdr.write(0x06);
  xdr.write(0x5A);
  xdr.stop();
  xdr.start(0x38 | I2C_WRITE);
  xdr.write(0x00);
  xdr.write(0x00);
  xdr.write(0x35);
  xdr.write(0x00);
  xdr.write(0x40);
  xdr.stop();
  mode = 1;
  FIR(-1); // adaptive filter bandwidth
}


void RDS()
{
  uint8_t rds_status, buffer[2];
  xdr.start(0x38 | I2C_WRITE);
    xdr.write(0x00); 
    xdr.write(0x00); 
    xdr.write(0x30);
  xdr.restart(0x38 | I2C_READ);
    xdr.read(false);
    rds_status = xdr.read(true);
  xdr.stop();
  
  xdr.start(0x38 | I2C_WRITE);
    xdr.write(0x00); 
    xdr.write(0x00); 
    xdr.write(0x31);
  xdr.restart(0x38 | I2C_READ);
    buffer[0] = xdr.read(false);
    buffer[1] = xdr.read(true);
  xdr.stop();
  switch(rds_status)
  {
    case 0x80: // block A - PI CODE
    case 0x81: // block A (max. 2 bit correction)
    case 0x82: // block A (max. 5 bit correction)
    case 0x90: // block C'
    case 0x91: // block C' (max. 2 bit correction)
    case 0x92: // block C' (max. 5 bit correction)
      if(pi_buffer[0] == buffer[0] && pi_buffer[1] == buffer[1])
      {
        Serial.print("P");
        serialHex(buffer[0]);
        serialHex(buffer[1]);
        Serial.println();
        pi_ok_buffer[0] = buffer[0];
        pi_ok_buffer[1] = buffer[1];
      } 
      else if (pi_ok_buffer[0] == buffer[0] && pi_ok_buffer[1] == buffer[1]) 
      {
        Serial.print("P");
        serialHex(buffer[0]);
        serialHex(buffer[1]);
        Serial.println();
        pi_buffer[0] = buffer[0];
        pi_buffer[1] = buffer[1];
      }
      else
      {
        if(pi_ok_buffer[0] == 0x00 && pi_ok_buffer[1] == 0x00 && rds_status == 0x80)
        {
          Serial.print("P");
          serialHex(buffer[0]);
          serialHex(buffer[1]);
          Serial.println("?");
        }
        pi_buffer[0] = buffer[0];
        pi_buffer[1] = buffer[1];
      }
    break;
    case 0x84: // block B
    case 0x85: // block B (max. 2 bit correction)
      // we will wait for block C & D before sending anything to the serial
      rds_buffer[0] = buffer[0];
      rds_buffer[1] = buffer[1];
      rds_buffer[2] = 0x00;
      rds_buffer[3] = 0x00;
      rds_timer = millis();
    break;
    case 0x88: // block C
    case 0x89: // block C (max. 2 bit correction)
      rds_buffer[2] = buffer[0];
      rds_buffer[3] = buffer[1];
    break;
    case 0x8C: // block D
    case 0x8D: // block D (max. 2 bit correction)
      // is this block related to the block B from buffer?
      if((millis()-rds_timer) < 50)
      {
         Serial.print("R"); 
         serialHex(rds_buffer[0]);
         serialHex(rds_buffer[1]);
         serialHex(rds_buffer[2]);
         serialHex(rds_buffer[3]);
         serialHex(buffer[0]);
         serialHex(buffer[1]); 
         Serial.println();
      }
    break;
  }
}

uint8_t querySAF(uint8_t addr1, uint8_t addr2, uint8_t addr3)
{
  uint8_t buffer;
  xdr.start(0x38 | I2C_WRITE);
    xdr.write(addr1); 
    xdr.write(addr2); 
    xdr.write(addr3);
  xdr.restart(0x38 | I2C_READ);
    buffer = xdr.read(true);
  xdr.stop();
  return buffer;
}

void spectrumUsage(int step, long start, long stop)
{
  uint8_t _PLLM = PLLM, _PLLL = PLLL, _DAA = DAA, _AGC = AGC, _BAND = BAND; // buffer current settings
  long tmp, freq;
  FIR(2); // fixed 90kHz bandwidth
  BAND = 0x31;
  tmp = (start - 87500)/5 + 19640;  
  for(int i=0; i<=((stop-start)/step); i++)
  {
    PLLM = tmp>>8 & 0xFF;
    PLLL = tmp&0xFF;
    freq = start + i*step;
    align(freq);
    tune();
    Serial.print(freq, DEC);
    Serial.print("=");
    delay(4);
    Serial.print(querySAF(0x03, 0x00, 0x92), DEC);
    Serial.print(" ");
    tmp+=step/5;
  }
  Serial.println();
  PLLM = _PLLM;
  PLLL = _PLLL;
  DAA = _DAA;
  AGC = _AGC;
  BAND = _BAND;
  tune();
  FIR(-1); // return to adaptive filter bandwidth
}

void align(long freq)
{
  // alignment of the antenna circuit
  // these values are individual for each tuner!
  if(freq>=107300)
    DAA = 52;
  else if(freq>=104500)
    DAA = 53;
  else if(freq>=100400)
    DAA = 54;
  else if(freq>=97500)
    DAA = 55;
  else if(freq>=95600)
    DAA = 56;
  else if(freq>=92900)
    DAA = 57;
  else if(freq>=90500)
    DAA = 58;
  else if(freq>=87800)
    DAA = 59;
  else if(freq>=87000)
    DAA = 60;
  else if(freq>=85000)
    DAA = 61;
  else if(freq>=84000)
    DAA = 62;
  else if(freq>=83000)
    DAA = 63;
  else if(freq>=78000)
    DAA = 64;
  else if(freq>=76000)
    DAA = 65;
  else if(freq>=74000)
    DAA = 66;
  else if(freq>=73000)
    DAA = 67;
  else if(freq>=70000)
    DAA = 69;
  else
    DAA = 70;
}
